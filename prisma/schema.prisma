generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  User              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Article {
  id               String   @id
  title            String
  slug             String   @unique
  excerpt          String?
  content          String
  tags             String[]
  published        Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime
  categories       String[]
  featuredImageUrl String?
  legacyUrl        String?
  editorId         String?
  editor           User?    @relation("ArticleEditor", fields: [editorId], references: [id])

  @@index([editorId])
  @@index([published])
  @@index([slug])
}

model GlossaryTerm {
  id        String   @id
  term      String   @unique
  slug      String   @unique
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime

  @@index([slug])
}

model Image {
  id        String   @id
  listingId String
  url       String
  alt       String?
  createdAt DateTime @default(now())
  Listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([listingId])
}

model Inquiry {
  id                String    @id
  listingId         String
  renterName        String
  renterEmail       String
  message           String
  status            String    @default("OPEN")
  createdAt         DateTime  @default(now())
  updatedAt         DateTime
  endDate           DateTime?
  startDate         DateTime?
  preferredCallTime String?
  renterPhone       String?
  replySentAt       DateTime?
  replyTemplate      String?   // confirmed, rejected, upsell, oder null f√ºr manuelle Antwort
  Listing           Listing   @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([listingId])
  @@index([status])
}

model Listing {
  id          String    @id
  ownerId     String
  title       String
  slug        String    @unique
  description String
  pricePerDay Int
  seats       Int
  beds        Int
  location    String
  features    String[]
  marke       String?
  equipment   Json?     // Strukturierte Ausstattungsdaten
  published   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime
  lat         Float?
  lng         Float?
  Image       Image[]
  Inquiry     Inquiry[]
  User        User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@index([lat, lng])
  @@index([location])
  @@index([published])
  @@index([slug])
  @@index([marke])
}

model NewsletterSubscriber {
  id                       String           @id
  email                    String           @unique
  name                     String?
  lists                    NewsletterList[]
  confirmed                Boolean          @default(false)
  confirmedAt              DateTime?
  unsubscribedAt           DateTime?
  createdAt                DateTime         @default(now())
  updatedAt                DateTime
  confirmationToken        String?          @unique
  confirmationTokenExpires DateTime?

  @@index([confirmationToken])
  @@index([confirmed])
  @@index([email])
}

model PasswordResetToken {
  id        String   @id
  email     String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())

  @@index([email])
  @@index([expires])
  @@index([token])
}

model Redirect {
  id        String   @id
  fromPath  String   @unique
  toPath    String
  createdAt DateTime @default(now())
}

model Session {
  id           String   @id
  sessionToken String   @unique
  userId       String
  expires      DateTime
  User         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id
  email         String    @unique
  emailVerified DateTime?
  name          String?
  password      String
  role          Role      @default(LANDLORD)
  street        String?
  city          String?
  postalCode    String?
  country       String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime
  editorProfile Json?
  profileImage  String?
  Account       Account[]
  Article       Article[] @relation("ArticleEditor")
  Listing       Listing[]
  Session       Session[]
  Subscription  Subscription?
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum NewsletterList {
  NEWS
  REISEBERICHTE
  VERMIETUNGEN
}

model OutreachPlace {
  id              String    @id @default(uuid())
  name            String
  address         String?
  phone           String?
  website         String?
  email           String?
  latitude        String?
  longitude       String?
  googlePlaceId   String?   @unique
  googleCID       String?
  googleFID       String?
  rating          String?
  reviews         String?
  status          String?
  category        String?
  keyword         String?
  priceRange      String?
  timing          Json?     // Array von Timing-Objekten
  url             String?
  listingUrl      String?
  reviewsLink     String?
  contacted       Boolean   @default(false)
  contactedAt     DateTime?
  contactNotes    String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([name])
  @@index([contacted])
  @@index([googlePlaceId])
}

model Subscription {
  id                String   @id
  userId            String   @unique
  stripeCustomerId  String   @unique
  stripeSubscriptionId String? @unique
  stripePriceId     String
  status            String   // active, canceled, past_due, etc.
  currentPeriodEnd  DateTime?
  cancelAtPeriodEnd Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  User              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([status])
}

enum Role {
  ADMIN
  LANDLORD
  EDITOR
}
